h1. Overview

Canvas is a lightweight framework for HTML5 / JavaScript animation. 

Canvas is configuration-based - instead of defining animation behavior in 
executable code, behavior is defined in configuration files. Because the 
framework code is reused for different elements, it is much smaller than a 
fully executable animation.

{toc}

h1. Basics

h2. Scaling

One of the guiding principles behind the framework is that the developer should not have to worry about the device on which an animation is being played. Sizes of graphics object seem to be handled pretty well automatically. 

h3. Motion

Processing and screen refresh rates vary widely among devices called upon to realize the animation. To that end, object motion is scaled by the ratio between the nominal refresh rate (60/second) and the actual measured refresh rate (actually, a smoothed version of the ratio). This means for a slower device, an object will move more pixels per refresh than on a faster device. The object seems to move across the same percentage of the viewing area in the same amount of time, regardless of the device. This also serves to keep motion in sync with sound.

The framework has a concept of "distance". In the current implementation, images displayed by an operation with the closest distance value 1 move at the pixels/second rate (with respect to the ideal 96 dpi screen) defined by the operations speed. _For clarity's sake, I think it would be a good idea to associate the *normal* rate with a fixed distance - probably 10._
Elements with different distances move at different rates - if two elements are defined to be moving with the same speed, but are at different distances, the closer image moves faster than the more distant one - the speed is proportional to the distance.

h3. Size[1]

Because the new configuration mechanism allows instantiation of multiple images of multiple sizes from the same image file, it will now be practical to automatically scale images based on distance. 

h1. Configuration

h2. Elements

*This section is being replaced with the schema discussed in the "To DO":./TODO.html section.*

Canvas elements have several attributes.

- identifier := the element's unique identifier. May be textually meaningful
- image := for displayable elements, the image associated with the element
- distance := for displayable elements, the relative distance to the associated image
- duration := start and stop times for an element's visibility; multiple pairs of times may be specified.
For elements triggered by other than timing events, the start time is specified as "*". =:

p(((. Input durations are in one of the following formats:

p((((. start 
[start, (end)?] | [,end]
[[start, (end)?] | [,end](,[start, (end)?] | [,end])*]

p(((. after formatting, durations are of the form 

p((((. [[start,end](,[start2,end]*]

p(((. where 

p((((. start, end ::= numeric | "*"

p(((. If start and end are both numeric end >= start, otherwise the interval is ignored.
If start == "*", the operation is only started when initiated by an event
if the operation is initiated before a specified end time, the operation will be stopped when the end time is encountered (or when stopped by an event.
If end == "*", it is treated as POSITIVE_INFINITY.
It is suggested that operations started and stopped by events either have no duration specified or a duration specified as ["*","*"]
If "show" has a value of "true", an operation will always be active and duration will be ignored.

- operation := the operation attribute contains the operations that are to be executed for the element
- usecanvas := specifies an element whose canvas this element should be drawn on

h2. Operations

Operation configurations supply parameters to the operations that applied to elements.

h3. Defined operations

The following is a list of currently defined operations and their corresponding parameters

- banner := displays rotating text[1]

* "display parameters":'#display_parameters'
* align
* text
* rotate
* per_second

- bounce := image is bounced 

* top
* bottom

- clear := clear the image

- %(#fixed)fixed% := draw an element on the canvas at a fixed position

- move := move the image on the canvas

* "display parameters":'#display_parameters'
* cycle 

- pan := fills the background with the element image, and moves it as specified

* speed
* panin [1]
* panout [1]

- panin := slides a background image in, moving as specified [1]

* speed

- panout := slides a background image out [1]

* speed

h4. Parameter definitions

- bottom := identifies the lower range of motion for operation *bounce*
- top := identifies the upper range of motion for operation *bounce*

- cycle := if true, the element reenters the display from the edge opposite the one it disappeared from. [2] =:

- per_second := the number of rotations to make each second for operation *banner*
- rotate := the number of characters to move each rotation for operation *banner*
- text := the text to be displayed for operation *banner*

- panin := When true, specifies that the *pan* image will slide in at the beginning of
each duration or when the *pan* element is triggered by an event =:
- panout := When true, specifies that the *pan* image will slide out at the end of
each duration or when an event terminates the *pan* duration normally =:

h5(display_parameters). Display parameters

Display parameters denote where elements are to be placed

- align := adjusts a display image location reference point. Default is [top, left]. [3] 

- position := initial image position. May be percent of screen. _May replace position with separate _x_ and _y_.

- speed := Speed at which the element image moves across the screen. Scaled by 
element distance and screen refresh rate. =:

h2. Events, Signals, and Triggers [1]

Events serve as notification that something of interest has happened. Triggers are 
the mechanism by which events are recognized and processed and subsequent actions are 
initiated.

h3. Events

Events allow interaction between the user and the animation, as well as among elements themselves.

h4. Mouse events

Mouse events are raised when a mouse operation occurs over the visual manifestation of an element. Mouse events are _only_ triggered for the element visible at the point of the mouse operation, i.e., if the RGB color is not #000000 and the opacity is not zero. Mouse events are defined within operations that display graphic elements: the actions they trigger may also be defined there.

h4. Timer events

Timer events may be set to trigger element activation or termination. This is useful when fixed durations do not meet the animation needs. Timer events may be set to occur at fixed times, or at a time relative to the time they are created.

h4. Element events

Element events are raised when an element goes through a defined state transition. This could be element initialization, termination, or even position, e.g., _do x when the image hits the edge of the screen._ 

h3. Triggers

Events are happenings of interest. Triggers initiate the actions that are to be done
when those events occur.

h1. Features

_Speed_ is used as an example of how a fixed parameter can be replaced with a dynamic function. Currently speed is the only feature with such an implementation, but size (width and height) and distance should also be amenable to similar measures. 

*Note:* Instead of specifying _speed_, a motion function could be applied directly to position (x and y).

h2. Speed

Speed is defined for operations where images are moved across the page.

If an element is defined with a _distance_ parameter, as well as _speed_, the rate at which the element will move across the screen is scaled by the _distance_ value.

There are two ways to specify _speed_.

h3. Speed as an array

Speed may be specified as a two value array, the first item being speed in the _x_ direction and the second the _y_ direction. The units are nominal pixels per screen refresh, scaled by the distance, so for a "close" object, a speed of 1 makes it move about an inch/second on a 1:1 pixel ratio 96 dpi screen.

bc.. // configuration.js
configuration["item1"] = { ...
    operations:{
        move: {
            speed: [.3, 0], ...
        }
    }
}
    
p. If a number of elements are moving at the same logical speed, the speed may be 
specified in a variable.

bc.. // configuration.js
var drift = [.3, 0] ...
configuration["item1"] = { ...
    operations:{
        move: {
            speed: drift, ...
        }
    }
}
configuration["item2"] = { ...
    operations:{
        move: {
            speed: drift, ...
        }
    }
}
p. This ensures multiple elements are moving at the same rate.

h3. Speed as a function

Speed may need to be defined as a calculated value. This can be accomplished 
be defining a speed function. The function may be defined inline or at another 
location 

bc.. // configuration.js
...
configuration ["element"] = {
    distance : 2,
    duration : [ 0, "*" ],
    interval : 10,
    operation : {
        "move" : {
            speed : {
                start: [.3, .2],
                speed : deltaV
            },
            position : [ "20%", "60%" ],
            cycle : true
        },
    },
}
    
// calc.js
...
function deltaV(rt_element, rt_operation) {
    var operation = rt_operation.configuration
    var dx = rt_operation.state.dx || rt_operation.configuration.speed.start[0]
    var dy = rt_operation.state.dy || rt_operation.configuration.speed.start[1]
    //
    // Code that calculates the new speed
    //
    rt_operation.state.dx = dx
    rt_operation.state.dy = dy
    return [ dx, dy ]
}
p. The function is defined in the 
operation as rt_operation.speed.speed. Parameters are the runtime element and the runtime operation. 
The function returns a two dimensional array. 

Initial values and constants may also be defined within rt_operation.speed.

h2. Button Generation

Buttons are fixed elements that cause actions to be triggered - change content,
switch web pages, initiate or cancel animations, etc.

Buttons are not different from any other canvas elements (which can trigger actions of all sorts). What is different is that there is code to assist in the generation of buttons. 
This allows the generation of sets of buttons with far less work than generation of 
buttons individually as "fixed":./basics.html#fixed elements.

h4. Button definition

Button definition is comprised of two parts: a configuration that determines how a set of buttons is to be placed, and a set of button definitions, which indicate the graphic to be displayed, and the events triggered when mouse actions interact with the button.

The _createMenuButtons_ function takes the button configuration and button definitions to generate configuration imagesets and operation definitions, which are then transformed into the appropriate runtime elements.

h5. Button configuration

The button configuration defines the following fields:

- distance := The nominal distance to the button. Placing a button at a greater distance may allow other graphic objects to move in front of it, hiding both button and its function. =:

- positionIncr := The position increment. This is a two-element array, [dx, dy], where dx is the horizontal offset and dy is the vertical offset. These are multiplied by a button's _ix_ value to calculate the position of the button relative to _positionStart_ Future work may allow specification of dx and dy directly. =:

- positionStart := The position of the first button. This is a two-element array, [x, y], the position of the top left corner of the image to be displayed. Future work may allow specification of x and y directly. =:

- ix := The default position multiplier of the first button. If zero, the top left corner of the first button image is placed at the _positionStart_ location.

Example:

bc.. var menuButtonConfig = {
    distance : 5,
    positionIncr : [ 0, 64 ],
    positionStart : [ 0, 32 ],
    ix : 0,
}

h5. Button definition

Because button definition is a shortcut for regular image / operation definition, it makes sense to simplify the definitions as much as possible. To this end, even explicit specification of image files is optional.

A button definition is a JavaScript object, with each key being a button name, and the value defining the button attributes.
These attributes are:

- image(optional) := An array of one or two svg file names. The first file image is the button image displayed when the mouse is not over the button. If the mouse is over the button image, the second file is displayed as the button image. When the mouse is no longer over the button image, the second file image is removed and the first file image is displayed as the button image. If the second file is not specified, and the first file name is of the form _filename_.svg, an attempt is made to locate _filename_<notextile>_overlay.svg.</notextile> If this file exists, it is the source for the second file image.  If the _image_ parameter is not specified, the first file name is _key_.svg, and the second file name is _key_<notextile>_overlay.svg</notextile>, if it exists. =:

- events := Define mouse events and associated actions for a button. Note that if an overly image is defined for a button, a mouseover event cannot be defined for the button. The event name is one of the common mouse events, the associated value is a function executed when the event occurs. =:

- ix := Position multiplier for this button. Used to alter button position. Affects ix value for subsequent buttons that do not explicitly specify _ix_.[1] =:

Example:

bc.. var buttondefs = {
    button_next: {
        image: [ "button_next.svg", "button_next_overlay.svg" ],
        events: {
            click: function() { linkTo("../next.html") }
        }
    },
    button_about: {
        image: [ "button_about.svg" ],
        events: {
            click: function() { linkTo("../about.html") }
        }
    },
    button_private: {
        events: {
            click: function() { linkTo("../private.html") }
        }
    },
    button_design: {
        events: {
            click: function() { linkTo("../design.html") }
        },
        ix: 4,
    },
}

createMenuButtons(leftMenuButtonConfig, buttondefs)

h2. SVG

Scaled Vector Graphics (SVG) files allow the definition of scalable images.

Scalability includes a number of different transformations. For the current
implementation, we only consider width, height, and rotation. Matrix and skew transforms
will be added if there is a need.

Image width and height parameters are applied to the &lt;svg&gt; element.  As the rotation 
transformation on the &lt;svg&gt; element is only defined in SVG 2, 
transformations will be applied to a &lt;g&gt; element that contains all of the 
graphics in the &lt;svg&gt; element.

h3. Single sub-element SVG

For instance, if the following SVG file were to be displayed as 108px x 112px 
and rotated 20 degrees about its center

bc.. <svg version="1.0" xmlns="http://www.w3.org/2000/svg"
        viewBox="0 0 54.000000 56.000000"
        preserveAspectRatio="xMidYMid meet">
    <g fill="#000000" stroke="none">
        <path d="M133 503 ... -6z"/>
    </g>
</svg>
p. it would be transformed to:

bc.. <svg version="1.0" xmlns="http://www.w3.org/2000/svg"
        width="108pt" height="112pt" viewBox="0 0 54.000000 56.000000"
        preserveAspectRatio="xMidYMid meet">
    <g transform="rotate(20,27,28)"
        fill="#000000" stroke="none">
        <path d=" ... "/>
    </g>
</svg>
h3. Multiple sub-element SVG

p. If there are multiple elements directly below the &lt;svg&gt; element, they are
enclosed in a new &lt;g&gt; element.

bc.. <svg version="1.0" xmlns="http://www.w3.org/2000/svg"
        viewBox="0 0 54.000000 56.000000"
        preserveAspectRatio="xMidYMid meet">
    <g fill="#000000" stroke="none">
        <path d=" ... "/>
    </g>
    <g>
        <rect x=.../>
    </g>
</svg>
p. it would be transformed to:

bc.. <svg version="1.0" xmlns="http://www.w3.org/2000/svg"
        width="108pt" height="112pt" viewBox="0 0 54.000000 56.000000"
        preserveAspectRatio="xMidYMid meet">
    <g transform="rotate(20,27,28)">
        <g fill="#000000" stroke="none">
            <path d=" ... "/>
        </g>
        <g>
            <rect x=.../>
        </g>
    </g>
</svg>

h3. Added attributes

p. The added attributes are:
- &lt;svg&gt; width and height := Set to specified values. 
    If width and height are not specified, they are derived from the viewbox values. =:
    
- &lt;g&gt; transform := The rotation transformation.

h3. Dynamic transformations (Future)

If the width, height, and rotation are to vary, the &lt;svg&gt; content is altered programmatically.

*Note* This will be superseded by the _SVG file formats_ discussion in "To do":./TODO.html


h1. TODO

|_ID  |_Component |_Status |_Summary|
|>4 |events|Confirmed|add event mechanism|
|>6 |All|Confirmed|Use Execution queue for draw|
|>8 |configuration|Confirmed|Refactor configuration|
|>9 |configuration|Confirmed|Add audio/video configuration and execution components|
|>10|configuration|Confirmed|Fix image configuration copy from "configuration"|

h2. Restructure Configuration

In order to support configuration reuse, configuration and operation information need to be replicated to the rt_element and rt_operation. One of the concerns is whether the rt_element and rt_operation should be merged.

Of course, this probably implies that the configuration definition ought also be redone. It may be desirable to break out images to image sets and move the image display configuration parameters to the operations. Conversely, it might do to allow default parms to be defined with the image sets, but allow them to be overridden by the operations.

h3. Proposal:

Convert current _configuration_ to _imagesets_ and _operations_. Similarly, create _audiosets_ and _videosets_, though the latter implementation may be deferred.

h5. Imageset

bc.. 
var imageset = {}

imageset.bugs = {
    image : [ "bug.gif", "bug30.gif", "bug60.gif", "bug90.gif", "bug120.gif",
        "bug150.gif", "bug180.gif", "bug225.gif", "bug270.gif",
        "bug315.gif", "bug.png", "bug.svg" ],
    configuration: {
        distance : 5,
        interval : 10,
        align : [ "left", "top" ],
        loop : true
    }
}

p. An alternative imageset definition would have the ability to define individual image attributes

bc.. imageset.bugs = {
    image : {
        0: { name: "bug.gif",
            width: 54, height:56,
        },
        ...
        11: { name: "bug.svg",
        },
    },
    configuration: {
        distance : 5, interval : 10,
        align : [ "left", "top" ],
        loop : true
    }
}

h5. Operations

p. Operation definitions may specify function-based behavior.

bc.. 
var operation = {}

operation.bugs1 = {
    imageset: "bugs",
    operation: "fixed",
    duration: [0,"*"],
    position : [ 0, 0 ],
    events: {
        click: function(){...}
}

operation.bugs2 = {
    imageset: "bugs",
    duration: [0,"*"],
    distance: 4,
    events: {
        click: function(){...},
    speed : {
        dx : .02, dy : .02,
        constant : 2,
        speed : deltaV_edge // function
    },
    position : [ "20%", "60%" ],
    cycle : false
}

h5. Audio and Video

Audio and video configurations modeled after image definition. Audiosets and videosets behave in a manner analogous to images, but instead of duration being defined externally, audios and videos in sets play for their length before the next is invoked. Audio and video playback may loop. Playback may be initiated and terminated by duration or dynamically created events.

A possible enhancement is to add time delay elements in an audioset or videoset.

h6. Audioset Example

Videosets will use the same general format.

bc.. 
audioset.taps = {
    audio: [
    "c1.mp3","c1.mp3", "f1.mp3", 
    "c1.mp3", "f1.mp3","a2.mp3", 
    "c1.mp3", "f1.mp3","a2.mp3", 
    "c1.mp3", "f1.mp3","a2.mp3", 
    "f1.mp3","a2.mp3", "c2.mp3", 
    "a2.mp3", "f1.mp3", "c1.mp3", 
    "c1.mp3","c1.mp3", "f1.mp3"]
}

p. Referred to in an operation:

bc.. 
operation.taps = {
    audioset: "taps",
    operation: "sound",
    duration: [[5,20],[50,75]]
}

h6. Videoset

Videosets are used in the same manner as audiosets, with the addition of position and width and height parameters. While these may be specified in the videoset definition, they are generally specified in the operation definition.

Currently, videos are fixed-position. Future development may enable motile videos. 

h5. Images

The _images_ definitions are generated from the _imageset_ definitions and image file attributes and content. While the current plan is to generate _images_ from the _imagesets_ content, there is no practical reason why images can't be added dynamically.

_This needs to be revised to conform with the current implementation or the implementation to conform with this._

h4. Restructured Runtime

h5. Operation Runtime

p. Operation Runtime entries are initially generated from the operations and imagesets. Entries may be created, updated, or removed as events are triggered.

_Needs to be reformatted to conform with implementation._ 

bc.. 
runtime.bugs1 = {
    operation: "fixed",
    distance : 5, interval : 10,
    align : [ "left", "top" ],
    loop : true,
    images:{ 
        0: { ref: images["bug.gif"],
            width: 54.0, height: 56.0,
            image = img, // <- the image is instantiated for reuse
        },
        ...
        11:{
            ref: images["bug.svg"],
            width: 54.0, height: 56.0,
            image = img,
        },
    meta: {
        imageindexes: [0,1,2,3,4,5,6,7,8,9,10,11]
    },
    state: {
        x: 0, y: 0,
        imageIx: 0,
    },
}



h5. Image Runtime

bc.. 
canvas_base.runtime_images.bugs: {
    image: {
        "https://something.something.org/site/app/resources/bug.svg" : {
            url:    "https://something.something.org/site/app/resources/bug.svg",
            type:   "svg",
            host:   "something.something.org",
            path:   "..resources/"
            file:   "bug.svg",
            width:  "54",
            height: "56",
        },
    },
    configuration: {
        interval : 10,
        align : [ "left", "top" ],
        loop : true,
    }
}

h5. Internal Image definition

bc.. 
canvas_base.images["https://something.something.org/site/app/resources/bug.svg"] = {
    url:    "https://something.something.org/site/app/resources/bug.svg",
    type:   "svg",
    host:   "something.something.org",
    path:   "..resources/"
    file:   "bug.svg",
    width:  "54",
    height: "56",
    // Generated back references to runtime imagesets.
    runtime_imagesets: [code_base.runtime_images.bugs, code_base.runtime_images.svg],
}

h6. Non-SVG file formats

p. GIF, PNG, and other non-SVG files have fairly basic information, derived from the image or explicitly defined by the imageset definition.

bc.. 
canvas_base.images["https://something.something.org/site/app/resources/bug.svg"] = {
    url:    "https://something.something.org/site/app/resources/bug.gif",
    type:   "gif",
    host:   "something.something.org",
    path:   "../resources/"
    file:   "bug.gif",
    width:  "54",
    height: "56",
    // Generated back references to runtime imagesets.
    runtime_imagesets: [code_base.runtime_images.bugs],
}

h6. SVG file formats

p. SVG files are expanded if there is need to access their content. Element IDs are generated if the element does not have an ID. In most cases, if there is a need to programmatically alter lower-level content, the containing elements should have IDs defined.

If a top-level &lt;svg&gt; element has more than one sub-element, an intermediary &lt;g&gt; element is generated so attributes, such as "rotate", can be applied to all images as a unit.

Breakout of SVG parameter subfields is currently theoretical. The best implementation might be by functions. 

It would also be possible, and possibly desirable, to allow completely in-line SVG definitions.
Complete tagging of SVG element content could substitute for SVG expansion.

bc.. 
canvas_base.images["https://something.something.org/site/app/resources/bug.svg"] = {
    url:    "https://something.something.org/site/app/resources/bug.svg",
    type:   "svg",
    host:   "something.something.org",
    path:   "..resources/"
    file:   "bug.svg",
    width:  "54",
    height: "56",
    // Generated back references to runtime imagesets.
    runtime_imagesets: [code_base.runtime_images.bugs, code_base.runtime_images.svg],
    svg:    $("#svg_doc_id")
}

h1. Notes

fn1. Not yet implemented.

fn2. "true" is the current behavior.

fn3. Currently implemented for operation *fixed*.

